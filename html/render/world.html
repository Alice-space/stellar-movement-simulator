<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>render.world API documentation</title>
<meta name="description" content="用来生成3D世界 …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>render.world</code></h1>
</header>
<section id="section-intro">
<h2 id="3d">用来生成3D世界</h2>
<p>@Author: Alicespace<br>
@Date: 2019-11-18 08:06:30<br>
@LastEditTime : 2019-12-22 15:35:02</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;

## 用来生成3D世界  

@Author: Alicespace  
@Date: 2019-11-18 08:06:30  
@LastEditTime : 2019-12-22 15:35:02

&#39;&#39;&#39;

from calculate import calculateloop, Mem
from direct.interval.IntervalGlobal import Sequence, Parallel
from direct.interval.LerpInterval import LerpPosInterval
from panda3d.core import CollisionHandlerQueue, CollisionHandlerEvent, CollisionTraverser, CollisionSphere, CollisionNode, CollisionHandlerPusher, TransparencyAttrib, TextNode, PointLight, loadPrcFile, Point3, loadPrcFileData, WindowProperties, Texture, TextureStage, DirectionalLight, AmbientLight, VBase4, TexGenAttrib
from direct.particles.ParticleEffect import ParticleEffect
from direct.showbase.ShowBase import ShowBase
from panda3d.core import Filename
from direct.task import Task
from direct.actor import Actor
import os, sys
table_name = &#39;Star_info&#39;
time_rate = 300
Actors = {}
Sequences = {}
ObjOrder = 0
ActorsOn = [False for i in range(105)]
global pos_rate
pos_rate = 1


class cameraSpeed():
    &#39;&#39;&#39;
    摄像机速度控制类
    &#39;&#39;&#39;
    def __init__(self):
        self.defaultMoveSpeed = 10
        self.minVelocity = 0.001
        self.velocityDecayRate = 0.5
        self.Vx = 0
        self.Vy = 0
        self.Vz = 0

    def addVx(self, dt):
        &#39;&#39;&#39;
        更改x速度
        &#39;&#39;&#39;
        self.Vx += self.defaultMoveSpeed * dt

    def addVy(self, dt):
        &#39;&#39;&#39;
        更改y速度
        &#39;&#39;&#39;
        self.Vy += self.defaultMoveSpeed * dt

    def addVz(self, dt):
        &#39;&#39;&#39;
        更改z速度
        &#39;&#39;&#39;
        self.Vz += self.defaultMoveSpeed * dt

    def slideX(self):
        &#39;&#39;&#39;
        x方向滑动动画
        &#39;&#39;&#39;
        if (abs(self.Vx) &lt;= self.minVelocity):
            self.Vx = 0
        if (self.Vx != 0):
            self.Vx *= self.velocityDecayRate

    def slideY(self):
        &#39;&#39;&#39;
        y方向滑动动画
        &#39;&#39;&#39;
        if (abs(self.Vy) &lt;= self.minVelocity):
            self.Vy = 0
        if (self.Vy != 0):
            self.Vy *= self.velocityDecayRate

    def slideZ(self):
        &#39;&#39;&#39;
        z方向滑动动画
        &#39;&#39;&#39;
        if (abs(self.Vz) &lt;= self.minVelocity):
            self.Vz = 0
        if (self.Vz != 0):
            self.Vz *= self.velocityDecayRate


class world(ShowBase):
    &#39;&#39;&#39; 
    3D世界基类  
    &#39;&#39;&#39;
    def __init__(self):
        loadPrcFileData(&#39;&#39;, &#39;fullscreen false&#39;)
        self.collisionHandler()
        self.setup()
        self.regKey()
        self.setTasks()
        self.cameraCollision()
        self.setSky()
        self.data = {}

    def getPath(self):
        &#39;&#39;&#39;
        绝对路径获取  
        &#39;&#39;&#39;
        path = os.path.abspath(sys.path[0])
        self.currentDIR = Filename.fromOsSpecific(path).getFullpath()

    def setup(self):
        &#39;&#39;&#39;
        窗口初始设定  
        常量初始化  
        &#39;&#39;&#39;

        global prevMouseX
        global prevMouseY
        global prevMouseVal
        global prevDxs
        global prevDys
        global totalSmoothStore
        prevMouseVal = 0
        prevMouseX = 0
        prevMouseY = 0
        prevDxs = []
        prevDys = []
        totalSmoothStore = 10

        base.disableMouse()
        # 鼠标放在中间
        base.win.movePointer(0, int(base.win.getXSize() / 2),
                             int(base.win.getYSize() / 2))
        self.cameraSpeed = cameraSpeed()
        self.getPath()

    def cameraCollision(self):
        &#39;&#39;&#39;
        注册摄像机与星体表面的碰撞处理函数  
        &#39;&#39;&#39;
        base.cTrav = CollisionTraverser()
        pusher = CollisionHandlerPusher()
        fromObject = base.camera.attachNewNode(CollisionNode(&#39;cameracol&#39;))
        fromObject.node().addSolid(CollisionSphere(0, 0, 0, 5))
        pusher = CollisionHandlerPusher()
        pusher.addCollider(fromObject, base.camera, base.drive.node())
        base.cTrav.addCollider(fromObject, pusher)

    def takeMouseAway(self):
        &#39;&#39;&#39;
        用于与GUI交互时释放焦点，卸载世界刷新任务  
        &#39;&#39;&#39;
        props = WindowProperties()
        props.setCursorHidden(False)
        props.setMouseMode(WindowProperties.M_absolute)
        base.win.requestProperties(props)
        try:
            self.detectOrdTask.remove()
            self.calculateStarTask.remove()
        except:
            pass

    def takeMouseBack(self):
        &#39;&#39;&#39;
        用于与GUI交互时获取焦点，加载世界刷新任务
        &#39;&#39;&#39;
        props = WindowProperties()
        base.win.movePointer(0, int(base.win.getXSize() / 2),
                             int(base.win.getYSize() / 2))
        props.setCursorHidden(True)
        props.setMouseMode(WindowProperties.M_relative)
        base.win.requestProperties(props)
        self.detectOrdTask = base.taskMgr.add(self.detectOrd, &#34;freshMove&#34;)
        self.calculateStarTask = base.taskMgr.add(self.calculateStar,
                                                  &#39;calculateStar&#39;)
        self.refreshActors()

    def setTasks(self):
        &#39;&#39;&#39;
        添加控制任务  
        1. 摄像机移动  
        2. 天空球移动  
        3. 摄像机旋转  
        &#39;&#39;&#39;
        base.taskMgr.add(self.moveCamera, &#34;moveCamera&#34;)
        base.taskMgr.add(self.skysphereTask, &#34;SkySphere Task&#34;)
        base.taskMgr.add(self.spinCamera, &#34;spinCamera&#34;)

    def collisionHandler(self):
        &#39;&#39;&#39;
        注册星体相互碰撞的事件处理函数
        &#39;&#39;&#39;
        self.collHandEvent = CollisionHandlerEvent()
        self.collHandEvent.addInPattern(&#39;%fn-into-%in&#39;)
        self.accept(&#39;starscol-into-starscol&#39;, self.handleStarCollision)

    def handleStarCollision(self, entry):
        &#39;&#39;&#39;
        星体碰撞的粒子效果
        &#39;&#39;&#39;
        base.enableParticles()
        p = ParticleEffect()
        p.loadConfig(self.currentDIR + &#39;/res/config/dust.ptf&#39;)
        p.start(parent=base.render, renderParent=base.render)
        p.setPos(entry.getSurfacePoint(base.render))
        # TODO 视觉效果不明显，换一个？
        p.setScale(1000000)

    def regKey(self):
        &#39;&#39;&#39;
        注册按键响应事件
        &#39;&#39;&#39;
        # store keyMap
        self.keyMap = {
            &#34;left&#34;: 0,
            &#34;right&#34;: 0,
            &#34;forward&#34;: 0,
            &#34;backward&#34;: 0,
            &#34;up&#34;: 0,
            &#34;down&#34;: 0
        }
        # add key events
        self.accept(&#34;a&#34;, self.setKey, [&#34;left&#34;, True])
        self.accept(&#34;d&#34;, self.setKey, [&#34;right&#34;, True])
        self.accept(&#34;w&#34;, self.setKey, [&#34;forward&#34;, True])
        self.accept(&#34;s&#34;, self.setKey, [&#34;backward&#34;, True])
        self.accept(&#34;space&#34;, self.setKey, [&#34;up&#34;, True])
        self.accept(&#34;lshift&#34;, self.setKey, [&#34;down&#34;, True])
        self.accept(&#34;a-up&#34;, self.setKey, [&#34;left&#34;, False])
        self.accept(&#34;d-up&#34;, self.setKey, [&#34;right&#34;, False])
        self.accept(&#34;w-up&#34;, self.setKey, [&#34;forward&#34;, False])
        self.accept(&#34;s-up&#34;, self.setKey, [&#34;backward&#34;, False])
        self.accept(&#34;space-up&#34;, self.setKey, [&#34;up&#34;, False])
        self.accept(&#34;lshift-up&#34;, self.setKey, [&#34;down&#34;, False])

    def setSky(self):
        &#39;&#39;&#39;
        加载天空球
        &#39;&#39;&#39;
        # load sky sphere
        self.skysphere = base.loader.loadModel(self.currentDIR +
                                               &#34;/res/skyBg/InvertedSphere.egg&#34;)
        self.skysphere.setTexGen(TextureStage.getDefault(),
                                 TexGenAttrib.MWorldPosition)
        self.skysphere.setTexProjector(TextureStage.getDefault(), base.render,
                                       self.skysphere)
        self.skysphere.setTexPos(TextureStage.getDefault(), 0, 0, 0)
        self.skysphere.setTexScale(TextureStage.getDefault(), .5)
        tex = base.loader.loadCubeMap(self.currentDIR +
                                      &#34;/res/skyBg/BlueGreenNebula__#.png&#34;)
        self.skysphere.setTexture(tex)
        self.skysphere.setLightOff()
        self.skysphere.setScale(10000)
        self.skysphere.reparentTo(base.render)
        self.skysphere.setBin(&#39;background&#39;, 1)
        self.skysphere.setDepthWrite(0)
        self.skysphere.reparentTo(base.render)

    def skysphereTask(self, task):
        &#39;&#39;&#39;
        移动天空球
        &#39;&#39;&#39;
        self.skysphere.setPos(base.camera, 0, 0, 0)
        return task.cont

    # Records thse state of the arrow keys
    def setKey(self, key, value):
        &#39;&#39;&#39;
        注册按键函数
        &#39;&#39;&#39;
        self.keyMap[key] = value

    # Define a procedure to move the camera.
    def moveCamera(self, task):
        &#39;&#39;&#39;
        注册```Panda```任务来移动摄像机
        &#39;&#39;&#39;
        dt = globalClock.getDt()

        # deal with movement events
        isXMoved = False
        isYMoved = False
        isZMoved = False

        # judge movement
        if self.keyMap[&#34;left&#34;]:
            if self.cameraSpeed.Vx &gt; 0:
                self.cameraSpeed.slideX()
            self.cameraSpeed.addVx(-dt)
            isXMoved = True
        if self.keyMap[&#34;right&#34;]:
            if self.cameraSpeed.Vx &lt; 0:
                self.cameraSpeed.slideX()
            self.cameraSpeed.addVx(dt)
            isXMoved = True
        if self.keyMap[&#34;forward&#34;]:
            if self.cameraSpeed.Vy &lt; 0:
                self.cameraSpeed.slideY()
            self.cameraSpeed.addVy(dt)
            isYMoved = True
        if self.keyMap[&#34;backward&#34;]:
            if self.cameraSpeed.Vy &gt; 0:
                self.cameraSpeed.slideY()
            self.cameraSpeed.addVy(-dt)
            isYMoved = True
        if not isXMoved:
            self.cameraSpeed.slideX()
        if not isYMoved:
            self.cameraSpeed.slideY()
        base.camera.setX(base.camera, self.cameraSpeed.Vx * 0.5)
        base.camera.setY(base.camera, self.cameraSpeed.Vy)
        return task.cont

    def spinCamera(self, task):
        &#39;&#39;&#39;
        注册```Panda```任务来旋转摄像机
        &#39;&#39;&#39;
        global prevMouseX
        global prevMouseY
        global prevMouseVal
        global prevDxs
        global prevDys
        global totalSmoothStore
        centerX = base.win.getXSize() / 2
        centerY = base.win.getYSize() / 2
        md = base.win.getPointer(0)
        x = md.getX()
        y = md.getY()
        if prevMouseVal == 0:
            prevMouseVal = 1
            prevDxs = []
            prevDys = []
        else:
            dx = x - prevMouseX
            dy = y - prevMouseY
            if len(prevDxs) &gt; totalSmoothStore:
                prevDxs.pop(0)
            if len(prevDys) &gt; totalSmoothStore:
                prevDys.pop(0)

            prevDxs.append(dx)
            prevDys.append(dy)

            curAverageDx = 0.
            for curDx in prevDxs:
                curAverageDx += curDx
            curAverageDx = curAverageDx / len(prevDxs)

            curAverageDy = 0.
            for curDy in prevDys:
                curAverageDy += curDy
            curAverageDy = curAverageDy / len(prevDys)
            base.camera.setP(base.camera.getP() -
                             5 * globalClock.getDt() * curAverageDy)
            base.camera.setH(base.camera.getH() +
                             5 * globalClock.getDt() * curAverageDx)

        prevMouseX = x
        prevMouseY = y
        return task.cont

    def detectOrd(self, task):
        &#39;&#39;&#39;
        检测```calculate```模块的```order```，判断是否发生融合事件
        &#39;&#39;&#39;
        global objs
        global ObjOrder
        if Mem.triggerstate is False:
            for obj in objs:
                if ObjOrder != obj.order:
                    self.refreshActors()
                    ObjOrder = obj.order
                    return task.cont
                elif ObjOrder == obj.order:
                    self.refreshSequence(obj)
            return task.cont
        else:
            Mem.triggerstate = False
            objs = Mem.getcurrentobjects()
            return task.cont

    def refreshActors(self):
        &#39;&#39;&#39;
        判断发生融合事件后，进行从新加载世界操作
        &#39;&#39;&#39;
        global Actors
        global ActorsOn
        global Sequences
        for obj in Actors:
            Actors[obj].removeNode()
        Actors = {}
        ActorsOn = [False for i in range(105)]
        Sequences = {}
        self.loadmodelsinit()

    def getData(self):
        &#39;&#39;&#39;
        向GUI返回星体运动数据供显示
        &#39;&#39;&#39;
        return objs, self.data

    def refreshSequence(self, obj):
        &#39;&#39;&#39;
        更新```Panda```序列，用于控制形体的运动
        &#39;&#39;&#39;
        global Sequences, pos_rate
        if Sequences[obj.ID][0].isStopped() and ActorsOn[obj.ID] is True:
            Sequences[obj.ID] = Sequence()
            data = obj.dataOUT()
            self.data[obj.ID] = data
            Sequences[obj.ID].append(Actors[obj.ID].posInterval(
                data[0] * time_rate,
                Point3(data[4] * pos_rate, data[5] * pos_rate,
                       data[6] * pos_rate)))
            Sequences[obj.ID].start()

    def calculateStar(self, task):
        &#39;&#39;&#39;
        注册```Panda```任务，调用```calculate```进行计算
        &#39;&#39;&#39;
        calculateloop.loopjudge(length=100000)
        # task.delayTime += 1
        return task.cont

    def changeTimeRate(self, newRate):
        &#39;&#39;&#39;
        GUI调整时间比例的接口函数
        &#39;&#39;&#39;
        global time_rate
        time_rate = newRate

    def loadmodelsinit(self):
        &#39;&#39;&#39;
        初始化世界，加载星体模型，创建恒星粒子效果
        &#39;&#39;&#39;
        calculateloop.loopjudge(length=100000)
        global objs
        global Actors
        global ActorsOn
        global pos_rate
        objs = Mem.getcurrentobjects()
        for obj in objs:
            data = obj.dataOUT()
            ActorsOn[obj.ID] = True
            Actors[obj.ID] = base.loader.loadModel(
                self.currentDIR + &#39;/res/sphereTemplate/smiley.egg&#39;)
            tex = base.loader.loadTexture(obj.texture)
            Actors[obj.ID].setTexture(tex, 1)

            # Reparent the model to render.
            Actors[obj.ID].reparentTo(base.render)
            # Apply scale and position transforms on the model.

            Actors[obj.ID].setPos(data[4] * pos_rate, data[5] * pos_rate,
                                  data[6] * pos_rate)

            fromObject = Actors[obj.ID].attachNewNode(
                CollisionNode(&#39;starscol&#39;))
            fromObject.node().addSolid(CollisionSphere(0, 0, 0, 1.15))
            Actors[obj.ID].setScale(obj.radius * pos_rate)
            base.cTrav.addCollider(fromObject, self.collHandEvent)
            if obj.objtype == &#39;Ostar&#39; or obj.objtype == &#39;Gstar&#39;:
                base.enableParticles()
                p = ParticleEffect()
                p.loadConfig(self.currentDIR + &#39;/res/config/dust.ptf&#39;)
                p.start(parent=Actors[obj.ID], renderParent=Actors[obj.ID])
        global Sequences
        for obj in objs:
            Sequences[obj.ID] = Sequence()
            data = obj.dataOUT()
            self.data[obj.ID] = data
            Sequences[obj.ID].append(Actors[obj.ID].posInterval(
                data[0] * time_rate,
                Point3(data[4] * pos_rate, data[5] * pos_rate,
                       data[6] * pos_rate)))
            Sequences[obj.ID].start()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="render.world.cameraSpeed"><code class="flex name class">
<span>class <span class="ident">cameraSpeed</span></span>
</code></dt>
<dd>
<section class="desc"><p>摄像机速度控制类</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cameraSpeed():
    &#39;&#39;&#39;
    摄像机速度控制类
    &#39;&#39;&#39;
    def __init__(self):
        self.defaultMoveSpeed = 10
        self.minVelocity = 0.001
        self.velocityDecayRate = 0.5
        self.Vx = 0
        self.Vy = 0
        self.Vz = 0

    def addVx(self, dt):
        &#39;&#39;&#39;
        更改x速度
        &#39;&#39;&#39;
        self.Vx += self.defaultMoveSpeed * dt

    def addVy(self, dt):
        &#39;&#39;&#39;
        更改y速度
        &#39;&#39;&#39;
        self.Vy += self.defaultMoveSpeed * dt

    def addVz(self, dt):
        &#39;&#39;&#39;
        更改z速度
        &#39;&#39;&#39;
        self.Vz += self.defaultMoveSpeed * dt

    def slideX(self):
        &#39;&#39;&#39;
        x方向滑动动画
        &#39;&#39;&#39;
        if (abs(self.Vx) &lt;= self.minVelocity):
            self.Vx = 0
        if (self.Vx != 0):
            self.Vx *= self.velocityDecayRate

    def slideY(self):
        &#39;&#39;&#39;
        y方向滑动动画
        &#39;&#39;&#39;
        if (abs(self.Vy) &lt;= self.minVelocity):
            self.Vy = 0
        if (self.Vy != 0):
            self.Vy *= self.velocityDecayRate

    def slideZ(self):
        &#39;&#39;&#39;
        z方向滑动动画
        &#39;&#39;&#39;
        if (abs(self.Vz) &lt;= self.minVelocity):
            self.Vz = 0
        if (self.Vz != 0):
            self.Vz *= self.velocityDecayRate</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="render.world.cameraSpeed.addVx"><code class="name flex">
<span>def <span class="ident">addVx</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>更改x速度</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addVx(self, dt):
    &#39;&#39;&#39;
    更改x速度
    &#39;&#39;&#39;
    self.Vx += self.defaultMoveSpeed * dt</code></pre>
</details>
</dd>
<dt id="render.world.cameraSpeed.addVy"><code class="name flex">
<span>def <span class="ident">addVy</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>更改y速度</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addVy(self, dt):
    &#39;&#39;&#39;
    更改y速度
    &#39;&#39;&#39;
    self.Vy += self.defaultMoveSpeed * dt</code></pre>
</details>
</dd>
<dt id="render.world.cameraSpeed.addVz"><code class="name flex">
<span>def <span class="ident">addVz</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>更改z速度</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addVz(self, dt):
    &#39;&#39;&#39;
    更改z速度
    &#39;&#39;&#39;
    self.Vz += self.defaultMoveSpeed * dt</code></pre>
</details>
</dd>
<dt id="render.world.cameraSpeed.slideX"><code class="name flex">
<span>def <span class="ident">slideX</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>x方向滑动动画</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slideX(self):
    &#39;&#39;&#39;
    x方向滑动动画
    &#39;&#39;&#39;
    if (abs(self.Vx) &lt;= self.minVelocity):
        self.Vx = 0
    if (self.Vx != 0):
        self.Vx *= self.velocityDecayRate</code></pre>
</details>
</dd>
<dt id="render.world.cameraSpeed.slideY"><code class="name flex">
<span>def <span class="ident">slideY</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>y方向滑动动画</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slideY(self):
    &#39;&#39;&#39;
    y方向滑动动画
    &#39;&#39;&#39;
    if (abs(self.Vy) &lt;= self.minVelocity):
        self.Vy = 0
    if (self.Vy != 0):
        self.Vy *= self.velocityDecayRate</code></pre>
</details>
</dd>
<dt id="render.world.cameraSpeed.slideZ"><code class="name flex">
<span>def <span class="ident">slideZ</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>z方向滑动动画</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slideZ(self):
    &#39;&#39;&#39;
    z方向滑动动画
    &#39;&#39;&#39;
    if (abs(self.Vz) &lt;= self.minVelocity):
        self.Vz = 0
    if (self.Vz != 0):
        self.Vz *= self.velocityDecayRate</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="render.world.world"><code class="flex name class">
<span>class <span class="ident">world</span></span>
</code></dt>
<dd>
<section class="desc"><p>3D世界基类</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class world(ShowBase):
    &#39;&#39;&#39; 
    3D世界基类  
    &#39;&#39;&#39;
    def __init__(self):
        loadPrcFileData(&#39;&#39;, &#39;fullscreen false&#39;)
        self.collisionHandler()
        self.setup()
        self.regKey()
        self.setTasks()
        self.cameraCollision()
        self.setSky()
        self.data = {}

    def getPath(self):
        &#39;&#39;&#39;
        绝对路径获取  
        &#39;&#39;&#39;
        path = os.path.abspath(sys.path[0])
        self.currentDIR = Filename.fromOsSpecific(path).getFullpath()

    def setup(self):
        &#39;&#39;&#39;
        窗口初始设定  
        常量初始化  
        &#39;&#39;&#39;

        global prevMouseX
        global prevMouseY
        global prevMouseVal
        global prevDxs
        global prevDys
        global totalSmoothStore
        prevMouseVal = 0
        prevMouseX = 0
        prevMouseY = 0
        prevDxs = []
        prevDys = []
        totalSmoothStore = 10

        base.disableMouse()
        # 鼠标放在中间
        base.win.movePointer(0, int(base.win.getXSize() / 2),
                             int(base.win.getYSize() / 2))
        self.cameraSpeed = cameraSpeed()
        self.getPath()

    def cameraCollision(self):
        &#39;&#39;&#39;
        注册摄像机与星体表面的碰撞处理函数  
        &#39;&#39;&#39;
        base.cTrav = CollisionTraverser()
        pusher = CollisionHandlerPusher()
        fromObject = base.camera.attachNewNode(CollisionNode(&#39;cameracol&#39;))
        fromObject.node().addSolid(CollisionSphere(0, 0, 0, 5))
        pusher = CollisionHandlerPusher()
        pusher.addCollider(fromObject, base.camera, base.drive.node())
        base.cTrav.addCollider(fromObject, pusher)

    def takeMouseAway(self):
        &#39;&#39;&#39;
        用于与GUI交互时释放焦点，卸载世界刷新任务  
        &#39;&#39;&#39;
        props = WindowProperties()
        props.setCursorHidden(False)
        props.setMouseMode(WindowProperties.M_absolute)
        base.win.requestProperties(props)
        try:
            self.detectOrdTask.remove()
            self.calculateStarTask.remove()
        except:
            pass

    def takeMouseBack(self):
        &#39;&#39;&#39;
        用于与GUI交互时获取焦点，加载世界刷新任务
        &#39;&#39;&#39;
        props = WindowProperties()
        base.win.movePointer(0, int(base.win.getXSize() / 2),
                             int(base.win.getYSize() / 2))
        props.setCursorHidden(True)
        props.setMouseMode(WindowProperties.M_relative)
        base.win.requestProperties(props)
        self.detectOrdTask = base.taskMgr.add(self.detectOrd, &#34;freshMove&#34;)
        self.calculateStarTask = base.taskMgr.add(self.calculateStar,
                                                  &#39;calculateStar&#39;)
        self.refreshActors()

    def setTasks(self):
        &#39;&#39;&#39;
        添加控制任务  
        1. 摄像机移动  
        2. 天空球移动  
        3. 摄像机旋转  
        &#39;&#39;&#39;
        base.taskMgr.add(self.moveCamera, &#34;moveCamera&#34;)
        base.taskMgr.add(self.skysphereTask, &#34;SkySphere Task&#34;)
        base.taskMgr.add(self.spinCamera, &#34;spinCamera&#34;)

    def collisionHandler(self):
        &#39;&#39;&#39;
        注册星体相互碰撞的事件处理函数
        &#39;&#39;&#39;
        self.collHandEvent = CollisionHandlerEvent()
        self.collHandEvent.addInPattern(&#39;%fn-into-%in&#39;)
        self.accept(&#39;starscol-into-starscol&#39;, self.handleStarCollision)

    def handleStarCollision(self, entry):
        &#39;&#39;&#39;
        星体碰撞的粒子效果
        &#39;&#39;&#39;
        base.enableParticles()
        p = ParticleEffect()
        p.loadConfig(self.currentDIR + &#39;/res/config/dust.ptf&#39;)
        p.start(parent=base.render, renderParent=base.render)
        p.setPos(entry.getSurfacePoint(base.render))
        # TODO 视觉效果不明显，换一个？
        p.setScale(1000000)

    def regKey(self):
        &#39;&#39;&#39;
        注册按键响应事件
        &#39;&#39;&#39;
        # store keyMap
        self.keyMap = {
            &#34;left&#34;: 0,
            &#34;right&#34;: 0,
            &#34;forward&#34;: 0,
            &#34;backward&#34;: 0,
            &#34;up&#34;: 0,
            &#34;down&#34;: 0
        }
        # add key events
        self.accept(&#34;a&#34;, self.setKey, [&#34;left&#34;, True])
        self.accept(&#34;d&#34;, self.setKey, [&#34;right&#34;, True])
        self.accept(&#34;w&#34;, self.setKey, [&#34;forward&#34;, True])
        self.accept(&#34;s&#34;, self.setKey, [&#34;backward&#34;, True])
        self.accept(&#34;space&#34;, self.setKey, [&#34;up&#34;, True])
        self.accept(&#34;lshift&#34;, self.setKey, [&#34;down&#34;, True])
        self.accept(&#34;a-up&#34;, self.setKey, [&#34;left&#34;, False])
        self.accept(&#34;d-up&#34;, self.setKey, [&#34;right&#34;, False])
        self.accept(&#34;w-up&#34;, self.setKey, [&#34;forward&#34;, False])
        self.accept(&#34;s-up&#34;, self.setKey, [&#34;backward&#34;, False])
        self.accept(&#34;space-up&#34;, self.setKey, [&#34;up&#34;, False])
        self.accept(&#34;lshift-up&#34;, self.setKey, [&#34;down&#34;, False])

    def setSky(self):
        &#39;&#39;&#39;
        加载天空球
        &#39;&#39;&#39;
        # load sky sphere
        self.skysphere = base.loader.loadModel(self.currentDIR +
                                               &#34;/res/skyBg/InvertedSphere.egg&#34;)
        self.skysphere.setTexGen(TextureStage.getDefault(),
                                 TexGenAttrib.MWorldPosition)
        self.skysphere.setTexProjector(TextureStage.getDefault(), base.render,
                                       self.skysphere)
        self.skysphere.setTexPos(TextureStage.getDefault(), 0, 0, 0)
        self.skysphere.setTexScale(TextureStage.getDefault(), .5)
        tex = base.loader.loadCubeMap(self.currentDIR +
                                      &#34;/res/skyBg/BlueGreenNebula__#.png&#34;)
        self.skysphere.setTexture(tex)
        self.skysphere.setLightOff()
        self.skysphere.setScale(10000)
        self.skysphere.reparentTo(base.render)
        self.skysphere.setBin(&#39;background&#39;, 1)
        self.skysphere.setDepthWrite(0)
        self.skysphere.reparentTo(base.render)

    def skysphereTask(self, task):
        &#39;&#39;&#39;
        移动天空球
        &#39;&#39;&#39;
        self.skysphere.setPos(base.camera, 0, 0, 0)
        return task.cont

    # Records thse state of the arrow keys
    def setKey(self, key, value):
        &#39;&#39;&#39;
        注册按键函数
        &#39;&#39;&#39;
        self.keyMap[key] = value

    # Define a procedure to move the camera.
    def moveCamera(self, task):
        &#39;&#39;&#39;
        注册```Panda```任务来移动摄像机
        &#39;&#39;&#39;
        dt = globalClock.getDt()

        # deal with movement events
        isXMoved = False
        isYMoved = False
        isZMoved = False

        # judge movement
        if self.keyMap[&#34;left&#34;]:
            if self.cameraSpeed.Vx &gt; 0:
                self.cameraSpeed.slideX()
            self.cameraSpeed.addVx(-dt)
            isXMoved = True
        if self.keyMap[&#34;right&#34;]:
            if self.cameraSpeed.Vx &lt; 0:
                self.cameraSpeed.slideX()
            self.cameraSpeed.addVx(dt)
            isXMoved = True
        if self.keyMap[&#34;forward&#34;]:
            if self.cameraSpeed.Vy &lt; 0:
                self.cameraSpeed.slideY()
            self.cameraSpeed.addVy(dt)
            isYMoved = True
        if self.keyMap[&#34;backward&#34;]:
            if self.cameraSpeed.Vy &gt; 0:
                self.cameraSpeed.slideY()
            self.cameraSpeed.addVy(-dt)
            isYMoved = True
        if not isXMoved:
            self.cameraSpeed.slideX()
        if not isYMoved:
            self.cameraSpeed.slideY()
        base.camera.setX(base.camera, self.cameraSpeed.Vx * 0.5)
        base.camera.setY(base.camera, self.cameraSpeed.Vy)
        return task.cont

    def spinCamera(self, task):
        &#39;&#39;&#39;
        注册```Panda```任务来旋转摄像机
        &#39;&#39;&#39;
        global prevMouseX
        global prevMouseY
        global prevMouseVal
        global prevDxs
        global prevDys
        global totalSmoothStore
        centerX = base.win.getXSize() / 2
        centerY = base.win.getYSize() / 2
        md = base.win.getPointer(0)
        x = md.getX()
        y = md.getY()
        if prevMouseVal == 0:
            prevMouseVal = 1
            prevDxs = []
            prevDys = []
        else:
            dx = x - prevMouseX
            dy = y - prevMouseY
            if len(prevDxs) &gt; totalSmoothStore:
                prevDxs.pop(0)
            if len(prevDys) &gt; totalSmoothStore:
                prevDys.pop(0)

            prevDxs.append(dx)
            prevDys.append(dy)

            curAverageDx = 0.
            for curDx in prevDxs:
                curAverageDx += curDx
            curAverageDx = curAverageDx / len(prevDxs)

            curAverageDy = 0.
            for curDy in prevDys:
                curAverageDy += curDy
            curAverageDy = curAverageDy / len(prevDys)
            base.camera.setP(base.camera.getP() -
                             5 * globalClock.getDt() * curAverageDy)
            base.camera.setH(base.camera.getH() +
                             5 * globalClock.getDt() * curAverageDx)

        prevMouseX = x
        prevMouseY = y
        return task.cont

    def detectOrd(self, task):
        &#39;&#39;&#39;
        检测```calculate```模块的```order```，判断是否发生融合事件
        &#39;&#39;&#39;
        global objs
        global ObjOrder
        if Mem.triggerstate is False:
            for obj in objs:
                if ObjOrder != obj.order:
                    self.refreshActors()
                    ObjOrder = obj.order
                    return task.cont
                elif ObjOrder == obj.order:
                    self.refreshSequence(obj)
            return task.cont
        else:
            Mem.triggerstate = False
            objs = Mem.getcurrentobjects()
            return task.cont

    def refreshActors(self):
        &#39;&#39;&#39;
        判断发生融合事件后，进行从新加载世界操作
        &#39;&#39;&#39;
        global Actors
        global ActorsOn
        global Sequences
        for obj in Actors:
            Actors[obj].removeNode()
        Actors = {}
        ActorsOn = [False for i in range(105)]
        Sequences = {}
        self.loadmodelsinit()

    def getData(self):
        &#39;&#39;&#39;
        向GUI返回星体运动数据供显示
        &#39;&#39;&#39;
        return objs, self.data

    def refreshSequence(self, obj):
        &#39;&#39;&#39;
        更新```Panda```序列，用于控制形体的运动
        &#39;&#39;&#39;
        global Sequences, pos_rate
        if Sequences[obj.ID][0].isStopped() and ActorsOn[obj.ID] is True:
            Sequences[obj.ID] = Sequence()
            data = obj.dataOUT()
            self.data[obj.ID] = data
            Sequences[obj.ID].append(Actors[obj.ID].posInterval(
                data[0] * time_rate,
                Point3(data[4] * pos_rate, data[5] * pos_rate,
                       data[6] * pos_rate)))
            Sequences[obj.ID].start()

    def calculateStar(self, task):
        &#39;&#39;&#39;
        注册```Panda```任务，调用```calculate```进行计算
        &#39;&#39;&#39;
        calculateloop.loopjudge(length=100000)
        # task.delayTime += 1
        return task.cont

    def changeTimeRate(self, newRate):
        &#39;&#39;&#39;
        GUI调整时间比例的接口函数
        &#39;&#39;&#39;
        global time_rate
        time_rate = newRate

    def loadmodelsinit(self):
        &#39;&#39;&#39;
        初始化世界，加载星体模型，创建恒星粒子效果
        &#39;&#39;&#39;
        calculateloop.loopjudge(length=100000)
        global objs
        global Actors
        global ActorsOn
        global pos_rate
        objs = Mem.getcurrentobjects()
        for obj in objs:
            data = obj.dataOUT()
            ActorsOn[obj.ID] = True
            Actors[obj.ID] = base.loader.loadModel(
                self.currentDIR + &#39;/res/sphereTemplate/smiley.egg&#39;)
            tex = base.loader.loadTexture(obj.texture)
            Actors[obj.ID].setTexture(tex, 1)

            # Reparent the model to render.
            Actors[obj.ID].reparentTo(base.render)
            # Apply scale and position transforms on the model.

            Actors[obj.ID].setPos(data[4] * pos_rate, data[5] * pos_rate,
                                  data[6] * pos_rate)

            fromObject = Actors[obj.ID].attachNewNode(
                CollisionNode(&#39;starscol&#39;))
            fromObject.node().addSolid(CollisionSphere(0, 0, 0, 1.15))
            Actors[obj.ID].setScale(obj.radius * pos_rate)
            base.cTrav.addCollider(fromObject, self.collHandEvent)
            if obj.objtype == &#39;Ostar&#39; or obj.objtype == &#39;Gstar&#39;:
                base.enableParticles()
                p = ParticleEffect()
                p.loadConfig(self.currentDIR + &#39;/res/config/dust.ptf&#39;)
                p.start(parent=Actors[obj.ID], renderParent=Actors[obj.ID])
        global Sequences
        for obj in objs:
            Sequences[obj.ID] = Sequence()
            data = obj.dataOUT()
            self.data[obj.ID] = data
            Sequences[obj.ID].append(Actors[obj.ID].posInterval(
                data[0] * time_rate,
                Point3(data[4] * pos_rate, data[5] * pos_rate,
                       data[6] * pos_rate)))
            Sequences[obj.ID].start()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>direct.showbase.ShowBase.ShowBase</li>
<li>direct.showbase.DirectObject.DirectObject</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="render.world.world.calculateStar"><code class="name flex">
<span>def <span class="ident">calculateStar</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<section class="desc"><p>注册<code>Panda</code>任务，调用<code>calculate</code>进行计算</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculateStar(self, task):
    &#39;&#39;&#39;
    注册```Panda```任务，调用```calculate```进行计算
    &#39;&#39;&#39;
    calculateloop.loopjudge(length=100000)
    # task.delayTime += 1
    return task.cont</code></pre>
</details>
</dd>
<dt id="render.world.world.cameraCollision"><code class="name flex">
<span>def <span class="ident">cameraCollision</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>注册摄像机与星体表面的碰撞处理函数</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cameraCollision(self):
    &#39;&#39;&#39;
    注册摄像机与星体表面的碰撞处理函数  
    &#39;&#39;&#39;
    base.cTrav = CollisionTraverser()
    pusher = CollisionHandlerPusher()
    fromObject = base.camera.attachNewNode(CollisionNode(&#39;cameracol&#39;))
    fromObject.node().addSolid(CollisionSphere(0, 0, 0, 5))
    pusher = CollisionHandlerPusher()
    pusher.addCollider(fromObject, base.camera, base.drive.node())
    base.cTrav.addCollider(fromObject, pusher)</code></pre>
</details>
</dd>
<dt id="render.world.world.changeTimeRate"><code class="name flex">
<span>def <span class="ident">changeTimeRate</span></span>(<span>self, newRate)</span>
</code></dt>
<dd>
<section class="desc"><p>GUI调整时间比例的接口函数</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeTimeRate(self, newRate):
    &#39;&#39;&#39;
    GUI调整时间比例的接口函数
    &#39;&#39;&#39;
    global time_rate
    time_rate = newRate</code></pre>
</details>
</dd>
<dt id="render.world.world.collisionHandler"><code class="name flex">
<span>def <span class="ident">collisionHandler</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>注册星体相互碰撞的事件处理函数</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collisionHandler(self):
    &#39;&#39;&#39;
    注册星体相互碰撞的事件处理函数
    &#39;&#39;&#39;
    self.collHandEvent = CollisionHandlerEvent()
    self.collHandEvent.addInPattern(&#39;%fn-into-%in&#39;)
    self.accept(&#39;starscol-into-starscol&#39;, self.handleStarCollision)</code></pre>
</details>
</dd>
<dt id="render.world.world.detectOrd"><code class="name flex">
<span>def <span class="ident">detectOrd</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<section class="desc"><p>检测<code>calculate</code>模块的<code>order</code>，判断是否发生融合事件</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detectOrd(self, task):
    &#39;&#39;&#39;
    检测```calculate```模块的```order```，判断是否发生融合事件
    &#39;&#39;&#39;
    global objs
    global ObjOrder
    if Mem.triggerstate is False:
        for obj in objs:
            if ObjOrder != obj.order:
                self.refreshActors()
                ObjOrder = obj.order
                return task.cont
            elif ObjOrder == obj.order:
                self.refreshSequence(obj)
        return task.cont
    else:
        Mem.triggerstate = False
        objs = Mem.getcurrentobjects()
        return task.cont</code></pre>
</details>
</dd>
<dt id="render.world.world.getData"><code class="name flex">
<span>def <span class="ident">getData</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>向GUI返回星体运动数据供显示</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getData(self):
    &#39;&#39;&#39;
    向GUI返回星体运动数据供显示
    &#39;&#39;&#39;
    return objs, self.data</code></pre>
</details>
</dd>
<dt id="render.world.world.getPath"><code class="name flex">
<span>def <span class="ident">getPath</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>绝对路径获取</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPath(self):
    &#39;&#39;&#39;
    绝对路径获取  
    &#39;&#39;&#39;
    path = os.path.abspath(sys.path[0])
    self.currentDIR = Filename.fromOsSpecific(path).getFullpath()</code></pre>
</details>
</dd>
<dt id="render.world.world.handleStarCollision"><code class="name flex">
<span>def <span class="ident">handleStarCollision</span></span>(<span>self, entry)</span>
</code></dt>
<dd>
<section class="desc"><p>星体碰撞的粒子效果</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleStarCollision(self, entry):
    &#39;&#39;&#39;
    星体碰撞的粒子效果
    &#39;&#39;&#39;
    base.enableParticles()
    p = ParticleEffect()
    p.loadConfig(self.currentDIR + &#39;/res/config/dust.ptf&#39;)
    p.start(parent=base.render, renderParent=base.render)
    p.setPos(entry.getSurfacePoint(base.render))
    # TODO 视觉效果不明显，换一个？
    p.setScale(1000000)</code></pre>
</details>
</dd>
<dt id="render.world.world.loadmodelsinit"><code class="name flex">
<span>def <span class="ident">loadmodelsinit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>初始化世界，加载星体模型，创建恒星粒子效果</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadmodelsinit(self):
    &#39;&#39;&#39;
    初始化世界，加载星体模型，创建恒星粒子效果
    &#39;&#39;&#39;
    calculateloop.loopjudge(length=100000)
    global objs
    global Actors
    global ActorsOn
    global pos_rate
    objs = Mem.getcurrentobjects()
    for obj in objs:
        data = obj.dataOUT()
        ActorsOn[obj.ID] = True
        Actors[obj.ID] = base.loader.loadModel(
            self.currentDIR + &#39;/res/sphereTemplate/smiley.egg&#39;)
        tex = base.loader.loadTexture(obj.texture)
        Actors[obj.ID].setTexture(tex, 1)

        # Reparent the model to render.
        Actors[obj.ID].reparentTo(base.render)
        # Apply scale and position transforms on the model.

        Actors[obj.ID].setPos(data[4] * pos_rate, data[5] * pos_rate,
                              data[6] * pos_rate)

        fromObject = Actors[obj.ID].attachNewNode(
            CollisionNode(&#39;starscol&#39;))
        fromObject.node().addSolid(CollisionSphere(0, 0, 0, 1.15))
        Actors[obj.ID].setScale(obj.radius * pos_rate)
        base.cTrav.addCollider(fromObject, self.collHandEvent)
        if obj.objtype == &#39;Ostar&#39; or obj.objtype == &#39;Gstar&#39;:
            base.enableParticles()
            p = ParticleEffect()
            p.loadConfig(self.currentDIR + &#39;/res/config/dust.ptf&#39;)
            p.start(parent=Actors[obj.ID], renderParent=Actors[obj.ID])
    global Sequences
    for obj in objs:
        Sequences[obj.ID] = Sequence()
        data = obj.dataOUT()
        self.data[obj.ID] = data
        Sequences[obj.ID].append(Actors[obj.ID].posInterval(
            data[0] * time_rate,
            Point3(data[4] * pos_rate, data[5] * pos_rate,
                   data[6] * pos_rate)))
        Sequences[obj.ID].start()</code></pre>
</details>
</dd>
<dt id="render.world.world.moveCamera"><code class="name flex">
<span>def <span class="ident">moveCamera</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<section class="desc"><p>注册<code>Panda</code>任务来移动摄像机</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveCamera(self, task):
    &#39;&#39;&#39;
    注册```Panda```任务来移动摄像机
    &#39;&#39;&#39;
    dt = globalClock.getDt()

    # deal with movement events
    isXMoved = False
    isYMoved = False
    isZMoved = False

    # judge movement
    if self.keyMap[&#34;left&#34;]:
        if self.cameraSpeed.Vx &gt; 0:
            self.cameraSpeed.slideX()
        self.cameraSpeed.addVx(-dt)
        isXMoved = True
    if self.keyMap[&#34;right&#34;]:
        if self.cameraSpeed.Vx &lt; 0:
            self.cameraSpeed.slideX()
        self.cameraSpeed.addVx(dt)
        isXMoved = True
    if self.keyMap[&#34;forward&#34;]:
        if self.cameraSpeed.Vy &lt; 0:
            self.cameraSpeed.slideY()
        self.cameraSpeed.addVy(dt)
        isYMoved = True
    if self.keyMap[&#34;backward&#34;]:
        if self.cameraSpeed.Vy &gt; 0:
            self.cameraSpeed.slideY()
        self.cameraSpeed.addVy(-dt)
        isYMoved = True
    if not isXMoved:
        self.cameraSpeed.slideX()
    if not isYMoved:
        self.cameraSpeed.slideY()
    base.camera.setX(base.camera, self.cameraSpeed.Vx * 0.5)
    base.camera.setY(base.camera, self.cameraSpeed.Vy)
    return task.cont</code></pre>
</details>
</dd>
<dt id="render.world.world.refreshActors"><code class="name flex">
<span>def <span class="ident">refreshActors</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>判断发生融合事件后，进行从新加载世界操作</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshActors(self):
    &#39;&#39;&#39;
    判断发生融合事件后，进行从新加载世界操作
    &#39;&#39;&#39;
    global Actors
    global ActorsOn
    global Sequences
    for obj in Actors:
        Actors[obj].removeNode()
    Actors = {}
    ActorsOn = [False for i in range(105)]
    Sequences = {}
    self.loadmodelsinit()</code></pre>
</details>
</dd>
<dt id="render.world.world.refreshSequence"><code class="name flex">
<span>def <span class="ident">refreshSequence</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<section class="desc"><p>更新<code>Panda</code>序列，用于控制形体的运动</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshSequence(self, obj):
    &#39;&#39;&#39;
    更新```Panda```序列，用于控制形体的运动
    &#39;&#39;&#39;
    global Sequences, pos_rate
    if Sequences[obj.ID][0].isStopped() and ActorsOn[obj.ID] is True:
        Sequences[obj.ID] = Sequence()
        data = obj.dataOUT()
        self.data[obj.ID] = data
        Sequences[obj.ID].append(Actors[obj.ID].posInterval(
            data[0] * time_rate,
            Point3(data[4] * pos_rate, data[5] * pos_rate,
                   data[6] * pos_rate)))
        Sequences[obj.ID].start()</code></pre>
</details>
</dd>
<dt id="render.world.world.regKey"><code class="name flex">
<span>def <span class="ident">regKey</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>注册按键响应事件</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regKey(self):
    &#39;&#39;&#39;
    注册按键响应事件
    &#39;&#39;&#39;
    # store keyMap
    self.keyMap = {
        &#34;left&#34;: 0,
        &#34;right&#34;: 0,
        &#34;forward&#34;: 0,
        &#34;backward&#34;: 0,
        &#34;up&#34;: 0,
        &#34;down&#34;: 0
    }
    # add key events
    self.accept(&#34;a&#34;, self.setKey, [&#34;left&#34;, True])
    self.accept(&#34;d&#34;, self.setKey, [&#34;right&#34;, True])
    self.accept(&#34;w&#34;, self.setKey, [&#34;forward&#34;, True])
    self.accept(&#34;s&#34;, self.setKey, [&#34;backward&#34;, True])
    self.accept(&#34;space&#34;, self.setKey, [&#34;up&#34;, True])
    self.accept(&#34;lshift&#34;, self.setKey, [&#34;down&#34;, True])
    self.accept(&#34;a-up&#34;, self.setKey, [&#34;left&#34;, False])
    self.accept(&#34;d-up&#34;, self.setKey, [&#34;right&#34;, False])
    self.accept(&#34;w-up&#34;, self.setKey, [&#34;forward&#34;, False])
    self.accept(&#34;s-up&#34;, self.setKey, [&#34;backward&#34;, False])
    self.accept(&#34;space-up&#34;, self.setKey, [&#34;up&#34;, False])
    self.accept(&#34;lshift-up&#34;, self.setKey, [&#34;down&#34;, False])</code></pre>
</details>
</dd>
<dt id="render.world.world.setKey"><code class="name flex">
<span>def <span class="ident">setKey</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<section class="desc"><p>注册按键函数</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setKey(self, key, value):
    &#39;&#39;&#39;
    注册按键函数
    &#39;&#39;&#39;
    self.keyMap[key] = value</code></pre>
</details>
</dd>
<dt id="render.world.world.setSky"><code class="name flex">
<span>def <span class="ident">setSky</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>加载天空球</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSky(self):
    &#39;&#39;&#39;
    加载天空球
    &#39;&#39;&#39;
    # load sky sphere
    self.skysphere = base.loader.loadModel(self.currentDIR +
                                           &#34;/res/skyBg/InvertedSphere.egg&#34;)
    self.skysphere.setTexGen(TextureStage.getDefault(),
                             TexGenAttrib.MWorldPosition)
    self.skysphere.setTexProjector(TextureStage.getDefault(), base.render,
                                   self.skysphere)
    self.skysphere.setTexPos(TextureStage.getDefault(), 0, 0, 0)
    self.skysphere.setTexScale(TextureStage.getDefault(), .5)
    tex = base.loader.loadCubeMap(self.currentDIR +
                                  &#34;/res/skyBg/BlueGreenNebula__#.png&#34;)
    self.skysphere.setTexture(tex)
    self.skysphere.setLightOff()
    self.skysphere.setScale(10000)
    self.skysphere.reparentTo(base.render)
    self.skysphere.setBin(&#39;background&#39;, 1)
    self.skysphere.setDepthWrite(0)
    self.skysphere.reparentTo(base.render)</code></pre>
</details>
</dd>
<dt id="render.world.world.setTasks"><code class="name flex">
<span>def <span class="ident">setTasks</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>添加控制任务<br>
1. 摄像机移动<br>
2. 天空球移动<br>
3. 摄像机旋转</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTasks(self):
    &#39;&#39;&#39;
    添加控制任务  
    1. 摄像机移动  
    2. 天空球移动  
    3. 摄像机旋转  
    &#39;&#39;&#39;
    base.taskMgr.add(self.moveCamera, &#34;moveCamera&#34;)
    base.taskMgr.add(self.skysphereTask, &#34;SkySphere Task&#34;)
    base.taskMgr.add(self.spinCamera, &#34;spinCamera&#34;)</code></pre>
</details>
</dd>
<dt id="render.world.world.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>窗口初始设定<br>
常量初始化</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self):
    &#39;&#39;&#39;
    窗口初始设定  
    常量初始化  
    &#39;&#39;&#39;

    global prevMouseX
    global prevMouseY
    global prevMouseVal
    global prevDxs
    global prevDys
    global totalSmoothStore
    prevMouseVal = 0
    prevMouseX = 0
    prevMouseY = 0
    prevDxs = []
    prevDys = []
    totalSmoothStore = 10

    base.disableMouse()
    # 鼠标放在中间
    base.win.movePointer(0, int(base.win.getXSize() / 2),
                         int(base.win.getYSize() / 2))
    self.cameraSpeed = cameraSpeed()
    self.getPath()</code></pre>
</details>
</dd>
<dt id="render.world.world.skysphereTask"><code class="name flex">
<span>def <span class="ident">skysphereTask</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<section class="desc"><p>移动天空球</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skysphereTask(self, task):
    &#39;&#39;&#39;
    移动天空球
    &#39;&#39;&#39;
    self.skysphere.setPos(base.camera, 0, 0, 0)
    return task.cont</code></pre>
</details>
</dd>
<dt id="render.world.world.spinCamera"><code class="name flex">
<span>def <span class="ident">spinCamera</span></span>(<span>self, task)</span>
</code></dt>
<dd>
<section class="desc"><p>注册<code>Panda</code>任务来旋转摄像机</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spinCamera(self, task):
    &#39;&#39;&#39;
    注册```Panda```任务来旋转摄像机
    &#39;&#39;&#39;
    global prevMouseX
    global prevMouseY
    global prevMouseVal
    global prevDxs
    global prevDys
    global totalSmoothStore
    centerX = base.win.getXSize() / 2
    centerY = base.win.getYSize() / 2
    md = base.win.getPointer(0)
    x = md.getX()
    y = md.getY()
    if prevMouseVal == 0:
        prevMouseVal = 1
        prevDxs = []
        prevDys = []
    else:
        dx = x - prevMouseX
        dy = y - prevMouseY
        if len(prevDxs) &gt; totalSmoothStore:
            prevDxs.pop(0)
        if len(prevDys) &gt; totalSmoothStore:
            prevDys.pop(0)

        prevDxs.append(dx)
        prevDys.append(dy)

        curAverageDx = 0.
        for curDx in prevDxs:
            curAverageDx += curDx
        curAverageDx = curAverageDx / len(prevDxs)

        curAverageDy = 0.
        for curDy in prevDys:
            curAverageDy += curDy
        curAverageDy = curAverageDy / len(prevDys)
        base.camera.setP(base.camera.getP() -
                         5 * globalClock.getDt() * curAverageDy)
        base.camera.setH(base.camera.getH() +
                         5 * globalClock.getDt() * curAverageDx)

    prevMouseX = x
    prevMouseY = y
    return task.cont</code></pre>
</details>
</dd>
<dt id="render.world.world.takeMouseAway"><code class="name flex">
<span>def <span class="ident">takeMouseAway</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>用于与GUI交互时释放焦点，卸载世界刷新任务</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def takeMouseAway(self):
    &#39;&#39;&#39;
    用于与GUI交互时释放焦点，卸载世界刷新任务  
    &#39;&#39;&#39;
    props = WindowProperties()
    props.setCursorHidden(False)
    props.setMouseMode(WindowProperties.M_absolute)
    base.win.requestProperties(props)
    try:
        self.detectOrdTask.remove()
        self.calculateStarTask.remove()
    except:
        pass</code></pre>
</details>
</dd>
<dt id="render.world.world.takeMouseBack"><code class="name flex">
<span>def <span class="ident">takeMouseBack</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>用于与GUI交互时获取焦点，加载世界刷新任务</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def takeMouseBack(self):
    &#39;&#39;&#39;
    用于与GUI交互时获取焦点，加载世界刷新任务
    &#39;&#39;&#39;
    props = WindowProperties()
    base.win.movePointer(0, int(base.win.getXSize() / 2),
                         int(base.win.getYSize() / 2))
    props.setCursorHidden(True)
    props.setMouseMode(WindowProperties.M_relative)
    base.win.requestProperties(props)
    self.detectOrdTask = base.taskMgr.add(self.detectOrd, &#34;freshMove&#34;)
    self.calculateStarTask = base.taskMgr.add(self.calculateStar,
                                              &#39;calculateStar&#39;)
    self.refreshActors()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#3d">用来生成3D世界</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="render" href="index.html">render</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="render.world.cameraSpeed" href="#render.world.cameraSpeed">cameraSpeed</a></code></h4>
<ul class="two-column">
<li><code><a title="render.world.cameraSpeed.addVx" href="#render.world.cameraSpeed.addVx">addVx</a></code></li>
<li><code><a title="render.world.cameraSpeed.addVy" href="#render.world.cameraSpeed.addVy">addVy</a></code></li>
<li><code><a title="render.world.cameraSpeed.addVz" href="#render.world.cameraSpeed.addVz">addVz</a></code></li>
<li><code><a title="render.world.cameraSpeed.slideX" href="#render.world.cameraSpeed.slideX">slideX</a></code></li>
<li><code><a title="render.world.cameraSpeed.slideY" href="#render.world.cameraSpeed.slideY">slideY</a></code></li>
<li><code><a title="render.world.cameraSpeed.slideZ" href="#render.world.cameraSpeed.slideZ">slideZ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="render.world.world" href="#render.world.world">world</a></code></h4>
<ul class="two-column">
<li><code><a title="render.world.world.calculateStar" href="#render.world.world.calculateStar">calculateStar</a></code></li>
<li><code><a title="render.world.world.cameraCollision" href="#render.world.world.cameraCollision">cameraCollision</a></code></li>
<li><code><a title="render.world.world.changeTimeRate" href="#render.world.world.changeTimeRate">changeTimeRate</a></code></li>
<li><code><a title="render.world.world.collisionHandler" href="#render.world.world.collisionHandler">collisionHandler</a></code></li>
<li><code><a title="render.world.world.detectOrd" href="#render.world.world.detectOrd">detectOrd</a></code></li>
<li><code><a title="render.world.world.getData" href="#render.world.world.getData">getData</a></code></li>
<li><code><a title="render.world.world.getPath" href="#render.world.world.getPath">getPath</a></code></li>
<li><code><a title="render.world.world.handleStarCollision" href="#render.world.world.handleStarCollision">handleStarCollision</a></code></li>
<li><code><a title="render.world.world.loadmodelsinit" href="#render.world.world.loadmodelsinit">loadmodelsinit</a></code></li>
<li><code><a title="render.world.world.moveCamera" href="#render.world.world.moveCamera">moveCamera</a></code></li>
<li><code><a title="render.world.world.refreshActors" href="#render.world.world.refreshActors">refreshActors</a></code></li>
<li><code><a title="render.world.world.refreshSequence" href="#render.world.world.refreshSequence">refreshSequence</a></code></li>
<li><code><a title="render.world.world.regKey" href="#render.world.world.regKey">regKey</a></code></li>
<li><code><a title="render.world.world.setKey" href="#render.world.world.setKey">setKey</a></code></li>
<li><code><a title="render.world.world.setSky" href="#render.world.world.setSky">setSky</a></code></li>
<li><code><a title="render.world.world.setTasks" href="#render.world.world.setTasks">setTasks</a></code></li>
<li><code><a title="render.world.world.setup" href="#render.world.world.setup">setup</a></code></li>
<li><code><a title="render.world.world.skysphereTask" href="#render.world.world.skysphereTask">skysphereTask</a></code></li>
<li><code><a title="render.world.world.spinCamera" href="#render.world.world.spinCamera">spinCamera</a></code></li>
<li><code><a title="render.world.world.takeMouseAway" href="#render.world.world.takeMouseAway">takeMouseAway</a></code></li>
<li><code><a title="render.world.world.takeMouseBack" href="#render.world.world.takeMouseBack">takeMouseBack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>